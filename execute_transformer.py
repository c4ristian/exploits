#!/usr/bin/env python

"""
This script transforms a snapshot of the Exploit-DB stored in the data directory. The
results are written into a new CSV file in the same directory.
"""

# Imports
import csv
import os
import time
import pandas as pd
import pyfiglet
import pygments
from pygments.lexers import guess_lexer_for_filename


# Global variables
_DATA_PATH = "data/"
_INPUT_PATH = _DATA_PATH + "files_exploits.csv"
_OUTPUT_PATH = _DATA_PATH + "files_exploits_transformed.csv"
_TIMESTAMPS_PATH = _DATA_PATH + "timestamps.txt"
_EXPLOIT_DB_HOME = "/usr/share/exploitdb/"


def _parse_exploit_file(file_name):
    """
    This function parses a specific exploit file and returns its line count
    as well as its guessed programming language as a tuple.

    :param file_name: The file name.
    :return: The parameters as a tuple.
    """
    with open(file_name, encoding="UTF-8") as file:
        lines = file.readlines()
        text = "\n".join(lines)

        line_count = len(lines)

        try:
            lang_guessed = guess_lexer_for_filename(file_name, text).name
        except pygments.util.ClassNotFound:
            lang_guessed = None

        return line_count, lang_guessed


def _strip_extension(file_name):
    """
    This function strips the extension from a certain file name.

    :param file_name:  The file name.
    :return: The extension or None when no extension could be stripped.
    """
    file_name_str = str(file_name)

    if file_name_str is not None and "." in file_name_str:
        return file_name_str.partition('.')[-1]

    return None


def _main():
    """
    This procedure executes the script.

    :return: None.
    """
    # Print figlet
    print(pyfiglet.figlet_format("exploits"))

    # Load data
    print(f"Loading exploits from {_INPUT_PATH}")
    exploit_frame = pd.read_csv(_INPUT_PATH)

    print(f"Exploits loaded: {len(exploit_frame)}")
    exploit_frame.head()

    print("Performing transformations...")

    # Modify datatypes
    exploit_frame["date_published"] = pd.to_datetime(exploit_frame["date_published"])
    exploit_frame["date_added"] = pd.to_datetime(exploit_frame["date_added"])
    exploit_frame["date_updated"] = pd.to_datetime(exploit_frame["date_updated"])
    exploit_frame["port"] = exploit_frame["port"].astype("object")

    # Replace index by ID
    exploit_frame = exploit_frame.set_index("id")

    # Derive new fields
    exploit_frame["file_extension"] = exploit_frame["file"].apply(_strip_extension)
    exploit_frame["date_published_year"] = exploit_frame["date_published"].dt.year

    # Analyse files
    line_counts = []
    langs_guessed = []

    for i, file_name in enumerate(exploit_frame["file"]):
        full_path = _EXPLOIT_DB_HOME + file_name

        line_count, lang_guessed = _parse_exploit_file(full_path)
        line_counts.append(line_count)
        langs_guessed.append(lang_guessed)

        if i % 1000 == 0:
            print(f"{i} of {len(exploit_frame)} exploits processed")

    exploit_frame["file_line_count"] = line_counts
    exploit_frame["lang_guessed"] = langs_guessed

    # Write transformed data
    print(f"Writing transformed exploits to {_OUTPUT_PATH}")
    exploit_frame.to_csv(_OUTPUT_PATH, quoting=csv.QUOTE_NONNUMERIC)

    # Write timestamps
    print(f"Writing timestamps to {_TIMESTAMPS_PATH}")

    with open(_TIMESTAMPS_PATH, "w+", encoding="UTF-8") as time_file:
        snapshot_time = time.ctime(os.path.getmtime(_INPUT_PATH))
        transformation_time = time.ctime(time.time())
        time_file.write(f"Date of snapshot: {snapshot_time}\n")
        time_file.write(f"Date of transformation: {transformation_time}")

    print("Finished successfully!")


if __name__ == "__main__":
    _main()
